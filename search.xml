<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java8中stream流用法</title>
    <url>/2022/03/10/Java8%E4%B8%ADstream%E6%B5%81%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、流的创建操作"><a href="#一、流的创建操作" class="headerlink" title="一、流的创建操作"></a>一、流的创建操作</h2><ol>
<li><p>使用Collection下的 stream() 和 parallelStream() 方法<strong>（常用）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream(); <span class="comment">//获取一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="comment">//获取一个并行流</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Arrays 中的 stream() 方法，将数组转成流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(nums);<span class="comment">//通过数组生成流</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Stream中的静态方法：of()、iterate()、generate()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">stream2.forEach(System.out::println); <span class="comment">// 0 2 4 6 8 10</span></span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">2</span>);</span><br><span class="line">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 BufferedReader.lines() 方法，将每行内容转成流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;F:\\test_stream.txt&quot;</span>));</span><br><span class="line">Stream&lt;String&gt; lineStream = reader.lines();</span><br><span class="line">lineStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Pattern.splitAsStream() 方法，将字符串分隔成流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="string">&quot;a,b,c,d&quot;</span>);</span><br><span class="line">stringStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二、流的中间操作"><a href="#二、流的中间操作" class="headerlink" title="二、流的中间操作"></a>二、流的中间操作</h2><h3 id="1、筛选与切片"><a href="#1、筛选与切片" class="headerlink" title="1、筛选与切片"></a>1、筛选与切片</h3><p>filter：过滤流中的某些元素。</p>
<p>limit(n)：获取n个元素。</p>
<p>skip(n)：跳过n元素，配合limit(n)可实现分页。</p>
<p>distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">14</span>);</span><br><span class="line"> </span><br><span class="line">Stream&lt;Integer&gt; newStream = stream</span><br><span class="line">    	.filter(s -&gt; s &gt; <span class="number">5</span>) <span class="comment">//过滤出大于5的：6 6 7 9 8 10 12 14 14</span></span><br><span class="line">        .distinct()         <span class="comment">//去重：6 7 9 8 10 12 14</span></span><br><span class="line">        .skip(<span class="number">2</span>)            <span class="comment">//跳过2个元素：9 8 10 12 14</span></span><br><span class="line">        .limit(<span class="number">2</span>);          <span class="comment">//获取2个元素：9 8</span></span><br><span class="line">newStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="2、映射"><a href="#2、映射" class="headerlink" title="2、映射"></a>2、映射</h3><p>map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。<br>flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;1,2,3&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将每个元素转成一个新的且不带逗号的元素</span></span><br><span class="line">Stream&lt;String&gt; s1 = list.stream().map(s -&gt; s.replaceAll(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">s1.forEach(System.out::println); <span class="comment">// abc  123</span></span><br><span class="line"> </span><br><span class="line">Stream&lt;String&gt; s3 = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">    <span class="comment">//将每个元素转换成一个stream</span></span><br><span class="line">    String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;);</span><br><span class="line">s3.forEach(System.out::println); <span class="comment">// a b c 1 2 3</span></span><br></pre></td></tr></table></figure>

<h3 id="3、排序"><a href="#3、排序" class="headerlink" title="3、排序"></a>3、排序</h3><p>sorted()：自然排序，流中元素需实现Comparable接口<br>sorted(Comparator com)：定制排序，自定义Comparator排序器 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ff&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line"><span class="comment">//String 类自身已实现Compareable接口</span></span><br><span class="line">list.stream().sorted().forEach(System.out::println);<span class="comment">// aa dd ff</span></span><br><span class="line"> </span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aa&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;dd&quot;</span>, <span class="number">40</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2, s3, s4);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义排序：先按姓名升序，姓名相同则按年龄升序</span></span><br><span class="line">studentList.stream().sorted(</span><br><span class="line">        (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.getName().equals(o2.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="4、消费"><a href="#4、消费" class="headerlink" title="4、消费"></a>4、消费</h3><p>peek：如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2);</span><br><span class="line"> </span><br><span class="line">studentList.stream()</span><br><span class="line">        .peek(o -&gt; o.setAge(<span class="number">100</span>))</span><br><span class="line">        .forEach(System.out::println);   </span><br><span class="line"> </span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;aa&#x27;</span>, age=<span class="number">100</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;bb&#x27;</span>, age=<span class="number">100</span>&#125;            </span><br></pre></td></tr></table></figure>

<h2 id="三、流的终止操作"><a href="#三、流的终止操作" class="headerlink" title="三、流的终止操作"></a>三、流的终止操作</h2><h3 id="1、匹配、聚合操作"><a href="#1、匹配、聚合操作" class="headerlink" title="1、匹配、聚合操作"></a>1、匹配、聚合操作</h3><p>allMatch：接收一个 Predicate 函数，当流中每个元素都符合该断言时才返回true，否则返回false。<br>noneMatch：接收一个 Predicate 函数，当流中每个元素都不符合该断言时才返回true，否则返回false。<br>anyMatch：接收一个 Predicate 函数，只要流中有一个元素满足该断言则返回true，否则返回false。<br>findFirst：返回流中第一个元素。<br>findAny：返回流中的任意元素。<br>count：返回流中元素的总个数。<br>max：返回流中元素最大值。<br>min：返回流中元素最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> list.stream().allMatch(e -&gt; e &gt; <span class="number">10</span>); <span class="comment">//判断所有元素是否符合：false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> list.stream().noneMatch(e -&gt; e &gt; <span class="number">10</span>); <span class="comment">//判断所有元素是否不符合：true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> list.stream().anyMatch(e -&gt; e &gt; <span class="number">4</span>);  <span class="comment">//判断是否有一个元素符合：true</span></span><br><span class="line"> </span><br><span class="line"><span class="type">Integer</span> <span class="variable">findFirst</span> <span class="operator">=</span> list.stream().findFirst().get(); <span class="comment">//返回第一个元素:1</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">findAny</span> <span class="operator">=</span> list.stream().findAny().get(); <span class="comment">//返回任意一个元素：1</span></span><br><span class="line"> </span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().count(); <span class="comment">//返回流中元素总个数：5</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> list.stream().max(Integer::compareTo).get(); <span class="comment">//返回流中元素最大值：5</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">min</span> <span class="operator">=</span> list.stream().min(Integer::compareTo).get(); <span class="comment">//返回流中元素最小值：1</span></span><br></pre></td></tr></table></figure>

<h3 id="2、规约操作"><a href="#2、规约操作" class="headerlink" title="2、规约操作"></a>2、规约操作</h3><p>规约操作又被称作折叠操作，是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。<em>Stream</em>类库有两个通用的规约操作<code>reduce()</code>和<code>collect()</code>，也有一些为简化书写而设计的专用规约操作，比如<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等。</p>
<h4 id="2-1reduce方法"><a href="#2-1reduce方法" class="headerlink" title="2.1reduce方法"></a>2.1reduce方法</h4><p><em>reduce</em>方法可以实现从一组元素中生成一个值，<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等都是<em>reduce</em>操作，将他们单独设为函数只是因为常用。</p>
<h3 id="3、收集操作"><a href="#3、收集操作" class="headerlink" title="3、收集操作"></a>3、收集操作</h3><p>从<em>Stream</em>生成一个集合或者<em>Map</em>等复杂的对象，需要用到collect方法；<code>collect()</code>是<em>Stream</em>接口方法中最灵活的一个，学会它才算真正入门Java函数式编程。</p>
<h4 id="3-1collect方法"><a href="#3-1collect方法" class="headerlink" title="3.1collect方法"></a>3.1collect方法</h4><h4 id="3-2搭配Collectors工具"><a href="#3-2搭配Collectors工具" class="headerlink" title="3.2搭配Collectors工具"></a>3.2搭配Collectors工具</h4><h5 id="a、生成Collection"><a href="#a、生成Collection" class="headerlink" title="a、生成Collection"></a>a、生成Collection</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>,<span class="number">2</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;cc&quot;</span>, <span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">List&lt;Student&gt; list = Arrays.asList(s1, s2, s3);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//转成List                  </span></span><br><span class="line">List&lt;Integer&gt; ageList = list.stream().map(Student::getAge).collect(Collectors.toList()); <span class="comment">//[10, 20, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转成Set                  </span></span><br><span class="line">Set&lt;Integer&gt; ageSet = list.stream().map(Student::getAge).collect(Collectors.toSet());<span class="comment">//[20, 10]</span></span><br></pre></td></tr></table></figure>

<p>上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过<code>Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)</code>方法完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用toCollection()指定规约容器的类型</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));<span class="comment">// (3)</span></span><br><span class="line"></span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));<span class="comment">// (4)</span></span><br></pre></td></tr></table></figure>

<h5 id="b、生成Map"><a href="#b、生成Map" class="headerlink" title="b、生成Map"></a>b、生成Map</h5><p>情况1：使用<code>toMap()</code>生成的收集器，这种情况是最直接的，前面例子中已提到，这是和<code>Collectors.toCollection()</code>并列的方法。key不能相同，否则报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、key和value都是对象中的某个属性值。</span></span><br><span class="line">Map&lt;String, String&gt; userMap1 = userList.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、key是对象中的某个属性值，value是对象本身（使用返回本身的lambda表达式）</span></span><br><span class="line">Map&lt;String, User&gt; userMap2 = userList.stream().collect(Collectors.toMap(User::getId, User -&gt; User));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、key是对象中的某个属性值，value是对象本身（使用Function.identity()的简洁写法）</span></span><br><span class="line">Map&lt;String, User&gt; userMap3 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、key是对象中的某个属性值，value是对象本身，当key冲突时选择第二个key值覆盖第一个key值</span></span><br><span class="line">Map&lt;String, User&gt; userMap4 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity(), (oldValue, newValue) -&gt; newValue));</span><br><span class="line"><span class="comment">//注：如果不正确指定Collectors.toMap方法的第三个参数（key冲突处理函数），那么在key重复的情况下该方法会报出【Duplicate Key】的错误导致Stream流异常终止，使用时要格外注意这一点。</span></span><br></pre></td></tr></table></figure>



<p>情况2：分区，使用<code>partitioningBy()</code>生成的收集器，这种情况适用于将<code>Stream</code>中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分区,分成两部分，一部分大于10岁，一部分小于等于10岁</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; partMap = list.stream().collect(Collectors.partitioningBy(v -&gt; v.getAge() &gt; <span class="number">10</span>));</span><br></pre></td></tr></table></figure>



<p>情况3：分组，使用<code>groupingBy()</code>生成的收集器，这是比较灵活的一种情况。跟SQL中的<em>group by</em>语句类似，这里的<em>groupingBy()<em>也是按照某个属性对数据进行分组，属性相同的元素会被对应到</em>Map</em>的同一个<em>key</em>上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分组</span></span><br><span class="line">Map&lt;Integer, List&lt;Student&gt;&gt; ageMap = list.stream().collect(Collectors.groupingBy(Student::getAge));</span><br><span class="line"></span><br><span class="line"><span class="comment">//多重分组,先根据类型分再根据年龄分</span></span><br><span class="line">Map&lt;Integer, Map&lt;Integer, List&lt;Student&gt;&gt;&gt; typeAgeMap = list.stream().collect(Collectors.groupingBy(Student::getType, Collectors.groupingBy(Student::getAge)));</span><br></pre></td></tr></table></figure>

<h5 id="c、生成字符串join"><a href="#c、生成字符串join" class="headerlink" title="c、生成字符串join"></a>c、生成字符串join</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转成String，并用分隔符连接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">joinName</span> <span class="operator">=</span> list.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>)); <span class="comment">//(aa,bb,cc)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-常用命令</title>
    <url>/2021/10/11/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="端口开放："><a href="#端口开放：" class="headerlink" title="端口开放："></a>端口开放：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有开放的端口：</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看想开的端口是否已开</span></span><br><span class="line">firewall-cmd --query-port=22/tcp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加指定需要开放的端口</span></span><br><span class="line">firewall-cmd --add-port=22/tcp --permanent</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载添加的端口</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除指定端口</span></span><br><span class="line">firewall-cmd --permanent --remove-port=22/tcp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例：开放8080端口</span></span><br><span class="line">firewall-cmd --query-port=8080/tcp               # 首先查看端口是否已经开放</span><br><span class="line">firewall-cmd --add-port=8080/tcp --permanent     # 开放端口</span><br><span class="line">firewall-cmd --reload                            # 重载</span><br></pre></td></tr></table></figure>

<h2 id="防火墙："><a href="#防火墙：" class="headerlink" title="防火墙："></a>防火墙：</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看防火墙状态</span></span><br><span class="line">systemctl status firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启防火墙</span></span><br><span class="line">service firewalld start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">若遇到无法开启</span></span><br><span class="line">systemctl unmask firewalld.service</span><br><span class="line">systemctl start firewalld.service</span><br></pre></td></tr></table></figure>

<h2 id="vim文本编辑："><a href="#vim文本编辑：" class="headerlink" title="vim文本编辑："></a>vim文本编辑：</h2><p>vim 共分为三种模式，<strong>命令模式、输入模式和底线命令行模式</strong>。</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>提供一些基本的命令，更多的命令需要使用底线命令行模式。</p>
<p><strong>刚进入vim时，就是命令模式。</strong></p>
<ul>
<li><p>从输入模式切换到命令模式：按ESC就可以从输入模式跳转为命令模式。</p>
</li>
<li><p>从底线命令行模式切换到命令模式：删除你输入的命令和冒号，再按ESC。</p>
</li>
<li><p><strong>i</strong> – 切换到输入模式，在光标当前位置开始输入文本。</p>
</li>
<li><p><strong>:</strong> – 切换到底线命令行模式，以在最底一行输入命令。</p>
</li>
</ul>
<h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><h3 id="底线命令行模式"><a href="#底线命令行模式" class="headerlink" title="底线命令行模式"></a>底线命令行模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搜索未注释和不空的行：</span></span><br><span class="line">grep -Ev &quot;^#|^$&quot; xxx.conf</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>commit信息类型规范</title>
    <url>/2025/05/29/commit%E4%BF%A1%E6%81%AF%E7%B1%BB%E5%9E%8B%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>在编写git commit信息时，可以遵循以下规范：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>fea</td>
<td>新功能</td>
</tr>
<tr>
<td>fix</td>
<td>修复bug</td>
</tr>
<tr>
<td>refactor</td>
<td>重构功能，不新增功能，也不修 bug</td>
</tr>
<tr>
<td>perf</td>
<td>性能优化</td>
</tr>
<tr>
<td>style</td>
<td>改代码风格，不影响功能</td>
</tr>
<tr>
<td>test</td>
<td>加测试、改测试</td>
</tr>
<tr>
<td>docs</td>
<td>改文档，比如 README</td>
</tr>
<tr>
<td>chore</td>
<td>杂项，比如改 .gitignore、构建脚本</td>
</tr>
<tr>
<td>ci</td>
<td>CI&#x2F;CD 相关改动</td>
</tr>
<tr>
<td>build</td>
<td>改构建系统或依赖</td>
</tr>
<tr>
<td>revert</td>
<td>回滚某个提交</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>例如：</p>
<p>fea(用户模块)：</p>
<p>新增用户接口。</p>
<p>fix(用户模块)：</p>
<p>修改接口报错问题修复。</p>
<p><strong>推荐IDEA插件：Git Commit Message Helper</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xibeifen/blogImage@main/img/image-20250702091208771.png" alt="image-20250702091208771"></p>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx-常用命令</title>
    <url>/2021/10/11/Nginx-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Windows下彻底关闭Nginx服务"><a href="#Windows下彻底关闭Nginx服务" class="headerlink" title="Windows下彻底关闭Nginx服务"></a>Windows下彻底关闭Nginx服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在nginx目录下打开cmd窗口，关闭Nginx服务，这样才能彻底关闭</span></span><br><span class="line">taskkill /f /t /im nginx.exe</span><br></pre></td></tr></table></figure>

<h2 id="Linux下常用命令"><a href="#Linux下常用命令" class="headerlink" title="Linux下常用命令"></a>Linux下常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动nginx</span></span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重载配置</span></span><br><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">立即停止nginx</span></span><br><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">平滑停止nginx</span></span><br><span class="line">/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nginx -h：查看帮助</span><br><span class="line"></span><br><span class="line">nginx -v：查看nginx的版本</span><br><span class="line">nginx -V：查看版本和nginx的配置选项</span><br><span class="line"></span><br><span class="line">nginx -t：测试配置文件的正确性</span><br><span class="line">nginx -T: 测试配置文件，并显示配置文件（这个命令可以快速查看配置文件）</span><br><span class="line">nginx -q：测试配置文件，但是只显示错误信息</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>SSE技术</title>
    <url>/2024/11/21/SSE%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h3 id="1、SSE通用工具类"><a href="#1、SSE通用工具类" class="headerlink" title="1、SSE通用工具类"></a>1、SSE通用工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.SseEmitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SSE工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xibeifeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/11/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SseUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前连接总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">CURRENT_CONNECT_TOTAL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * messageId的 SseEmitter对象映射集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, SseEmitter&gt; SSE_EMITTER_MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建sse连接</span></span><br><span class="line"><span class="comment">     * 注：每台电脑每个用户可以多次触发create，每次create对应一个messageId,</span></span><br><span class="line"><span class="comment">     * sseEmitter无法推送消息时，会自动删除对应的messageId。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SseEmitter <span class="title function_">createConnect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//消息id可以是随机数或者UUID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> String.valueOf(RandomUtils.nextInt(<span class="number">1</span>, <span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">return</span> createConnect(messageId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建sse连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SseEmitter <span class="title function_">createConnect</span><span class="params">(String messageId)</span> &#123;</span><br><span class="line">        <span class="comment">//设置连接超时时间。0表示不过期，默认是30秒，超过时间未完成会抛出异常</span></span><br><span class="line">        <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>(<span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册回调</span></span><br><span class="line">        sseEmitter.onCompletion(completionCallBack(messageId));</span><br><span class="line">        sseEmitter.onTimeout(timeOutCallBack(messageId));</span><br><span class="line">        sseEmitter.onError(errorCallBack(messageId));</span><br><span class="line">        SSE_EMITTER_MAP.put(messageId, sseEmitter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录一下连接总数。数量+1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> CURRENT_CONNECT_TOTAL.incrementAndGet();</span><br><span class="line">        log.info(<span class="string">&quot;创建sse连接成功 ==&gt; 当前连接总数=&#123;&#125;， messageId=&#123;&#125;&quot;</span>, count, messageId);</span><br><span class="line">        <span class="keyword">return</span> sseEmitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给指定 messageId发消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId - 消息id（唯一）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message   - 消息文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String messageId, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SSE_EMITTER_MAP.containsKey(messageId)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SSE_EMITTER_MAP.get(messageId).send(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;发送消息异常 ==&gt; messageId=&#123;&#125;, 异常信息：&#123;&#125;&quot;</span>, messageId, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;连接不存在或者超时， messageId=&quot;</span> + messageId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给所有 messageId广播发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">batchAllSendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始广播发送消息&quot;</span>);</span><br><span class="line">        SSE_EMITTER_MAP.forEach((messageId, sseEmitter) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sseEmitter.send(message, MediaType.APPLICATION_JSON);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;广播发送消息异常 ==&gt; messageId=&#123;&#125;, 异常信息：&#123;&#125;&quot;</span>, messageId, e.getMessage());</span><br><span class="line">                removeMessageId(messageId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给指定 messageId集合群发消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageIds 消息id集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message    消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">batchSendMessage</span><span class="params">(List&lt;String&gt; messageIds, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isEmpty(messageIds)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        messageIds = messageIds.stream().distinct().collect(Collectors.toList());</span><br><span class="line">        messageIds.forEach(userId -&gt; sendMessage(userId, message));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给指定组群发消息（即组播，我们让 messageId满足我们的组命名确定即可）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupId 组id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">groupSendMessage</span><span class="params">(String groupId, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (MapUtil.isEmpty(SSE_EMITTER_MAP)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SSE_EMITTER_MAP.forEach((messageId, sseEmitter) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里 groupId作为前缀</span></span><br><span class="line">                <span class="keyword">if</span> (messageId.startsWith(groupId)) &#123;</span><br><span class="line">                    sseEmitter.send(message, MediaType.APPLICATION_JSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;组播发送消息异常 ==&gt; groupId=&#123;&#125;, 异常信息：&#123;&#125;&quot;</span>, groupId, e.getMessage());</span><br><span class="line">                removeMessageId(messageId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 MessageId</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 消息 ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeMessageId</span><span class="params">(String messageId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SSE_EMITTER_MAP.containsKey(messageId)) &#123;</span><br><span class="line">            SSE_EMITTER_MAP.remove(messageId);</span><br><span class="line">            CURRENT_CONNECT_TOTAL.getAndDecrement();</span><br><span class="line">            log.info(<span class="string">&quot;移除 messageId=&#123;&#125;&quot;</span>, messageId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有的 MessageId集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> List&lt;String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getMessageIds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(SSE_EMITTER_MAP.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前连接总数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getConnectTotal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CURRENT_CONNECT_TOTAL.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开SSE连接时的回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 消息id（唯一）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title function_">completionCallBack</span><span class="params">(String messageId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;结束连接 ==&gt; messageId=&#123;&#125;&quot;</span>, messageId);</span><br><span class="line">            removeMessageId(messageId);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接超时时回调触发</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 消息id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title function_">timeOutCallBack</span><span class="params">(String messageId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;连接超时 ==&gt; messageId=&#123;&#125;&quot;</span>, messageId);</span><br><span class="line">            removeMessageId(messageId);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接报错时回调触发。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageId 消息id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Consumer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Consumer&lt;Throwable&gt; <span class="title function_">errorCallBack</span><span class="params">(String messageId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> throwable -&gt; &#123;</span><br><span class="line">            log.error(<span class="string">&quot;连接异常 ==&gt; messageId=&#123;&#125;&quot;</span>, messageId);</span><br><span class="line">            removeMessageId(messageId);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、业务controller"><a href="#2、业务controller" class="headerlink" title="2、业务controller"></a>2、业务controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.SseEmitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sse&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SseController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建sse连接,并返回SseEmitter对象</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SseEmitter <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SseUtil.createConnect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testConnect&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试连接&quot;</span>);</span><br><span class="line">        SseUtil.batchAllSendMessage(<span class="string">&quot;接收信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、postman测试"><a href="#3、postman测试" class="headerlink" title="3、postman测试"></a>3、postman测试</h3><ul>
<li>第一个接口用于创建连接：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xibeifen/blogImage@main/img/image-20241120145107518.png" alt="image-20241120145107518"></p>
<ul>
<li>第二个接口调用群发消息的方法：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xibeifen/blogImage@main/img/image-20241120145912725.png" alt="image-20241120145912725"></p>
<ul>
<li>查看第一个接口，SSE收到消息：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xibeifen/blogImage@main/img/image-20241120145941667.png" alt="image-20241120145941667"></p>
<h3 id="4、前端代码"><a href="#4、前端代码" class="headerlink" title="4、前端代码"></a>4、前端代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var sseSource = new EventSource(&quot;http://localhost:8080/sse/create&quot;);</span><br><span class="line">    sseSource.onmessage = function(event)&#123;</span><br><span class="line">        console.log(&quot;test=&gt;&quot;,event)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5、Nginx配置"><a href="#5、Nginx配置" class="headerlink" title="5、Nginx配置"></a>5、Nginx配置</h3><p>如果后端接口由Nginx代理，那么需要进行特定的配置；</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /sse/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8080/sse/;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保使用HTTP 1.1长连接</span></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 避免Nginx关闭连接</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 防止超时断开</span></span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">proxy_send_timeout</span> <span class="number">10m</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 禁用缓冲</span></span><br><span class="line">    <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_cache</span> <span class="literal">off</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 可选：多数情况下非必需,如果上面都不行，就禁用这个试试吧</span></span><br><span class="line">    <span class="comment">#chunked_transfer_encoding off; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Nginx配置SSE明细：</strong></p>
<ul>
<li>❤<strong>proxy_read_timeout 10m;(核心作用)</strong></li>
</ul>
<p><strong>说明：</strong>定义Nginx从后端服务器读取数据的超时时间（默认60秒）；单位可以是 <code>s</code>、<code>m</code>、<code>h</code>、<code>d</code>。</p>
<p>SSE依赖<strong>持久化长连接</strong>，后端服务器可能长时间不发送数据（例如无新事件时），但连接需保持存活；</p>
<p>若超时时间过短（如默认60秒），Nginx会误以为连接已断开，主动关闭连接，导致SSE客户端断连。</p>
<p><strong>推荐值</strong>：设置为<strong>远大于SSE事件间隔的时间</strong>（如10分钟或更长），确保连接在无数据时仍存活。</p>
<ul>
<li><strong>proxy_send_timeout 10m;（辅助配置，和上面保持一致）</strong></li>
</ul>
<p><strong>说明：</strong>定义Nginx向客户端发送数据的超时时间（默认60秒）。</p>
<p>SSE中，Nginx通常<strong>被动转发</strong>后端数据，极少主动发送数据（除非有反向代理或负载均衡场景）；</p>
<p>若客户端网络延迟高或处理慢，Nginx可能因超时关闭连接（但SSE客户端通常能快速消费数据，此问题较少见）；</p>
<p><strong>推荐值</strong>：与 <code>proxy_read_timeout</code> 一致（如 <code>10m</code>）。</p>
<ul>
<li><strong>proxy_connect_timeout 10s;（通常无需修改）</strong></li>
</ul>
<p><strong>说明：</strong>定义Nginx与<strong>后端服务器</strong>建立TCP连接的超时时间（默认60秒）。</p>
<p>SSE场景中，连接建立通常很快（毫秒级），除非后端服务器负载极高或网络不稳定；</p>
<p>默认值通常足够，仅在极端情况下（如后端启动慢）需调整；</p>
<p><strong>推荐值</strong>：保持默认或略高于平均连接时间（如 <code>5s</code>），<strong>无需设置过长</strong>。</p>
<ul>
<li>❤<strong>proxy_buffering off;(核心作用)</strong></li>
</ul>
<p><strong>说明：</strong>Nginx默认会缓冲代理请求和响应数据，导致SSE事件被缓存而非实时传递给客户端。SSE依赖持续的长连接推送实时数据，若事件被缓冲，客户端会延迟收</p>
<p>到数据，甚至连接看似无响应。</p>
<p>通过 <code>proxy_buffering off;</code> 禁用缓冲，确保Nginx直接转发数据，不进行中间存储。这是SSE正常工作的基础配置，<strong>无此配置，SSE可能完全失效</strong>。</p>
<ul>
<li><strong>proxy_cache off;(辅助配置，确保无缓存)</strong></li>
</ul>
<p><strong>说明：</strong>显式禁用Nginx的代理缓存功能，防止SSE响应被缓存。虽然SSE本身是实时流，通常不会被缓存，但显式关闭可避免潜在冲突（如其他中间件或误配置的缓</p>
<p>存规则）。</p>
<p>优先级低于 <code>proxy_buffering off;</code>。若已禁用缓冲，缓存问题通常不会出现，但作为最佳实践可一并配置。</p>
<ul>
<li><strong>chunked_transfer_encoding off;(根据场景确定是否配置)</strong></li>
</ul>
<p><strong>说明：</strong>禁用分块传输编码（Chunked Transfer Encoding），强制使用 <code>Content-Length</code> 头部。SSE通常不需要分块编码（因其有自定义数据帧格式），但Nginx</p>
<p>默认可能启用分块传输。</p>
<p><strong>多数情况下非必需</strong>：禁用分块编码可能避免Nginx因修改响应头引入意外行为，Nginx能正确处理SSE的MIME类型（<code>text/event-stream</code>），分块编码不会干扰SSE功能。</p>
<hr>
<p>❤<strong>如何“永久”保持连接呢？答：超长时间 或  心跳机制 或 客户端自动重连。</strong></p>
<p>也可以三种方法一起用；超长时间不用说， <code>proxy_read_timeout</code> 设置为365d或更大；客户端自动重连就是每隔一端时间发起重新连接；下面介绍服务端实现心跳机制的具体内容。</p>
<p>但即使 <code>proxy_read_timeout</code> 极大，若服务端<strong>完全不发送数据</strong>，Nginx仍可能因底层TCP保活机制或系统级超时关闭连接。因此服务端可以通过定期发送数据（即使是空数据或注释行）保持Nginx代理层与后端的连接活跃。</p>
<p><strong>心跳频率的选择</strong>：小于Nginx的<code>proxy_read_timeout</code>即可，例如<strong>15~60秒</strong>一次。</p>
<p>SSE允许发送无实际数据的<strong>注释行</strong>（以<code>:</code>开头的行，客户端会忽略），非常适合作为心跳信号。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码放在你的定时任务中,15~60秒执行一次(定时任务部分不再赘述)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sseEndpoint</span><span class="params">()</span> &#123;</span><br><span class="line">    SseUtil.batchAllSendMessage(<span class="string">&quot;: heartbeat&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>Linux通常还有<strong>系统级TCP保活</strong>，默认为2小时，net.ipv4.tcp_keepalive_time &#x3D; 7200，它会检测空闲连接是否存活，超时后关闭死连接，如果影响到你的“永久”连接，需要将它设置为更长时间。</p>
<p>参考：</p>
<p>[<a href="https://blog.csdn.net/qq_42402854/article/details/130932936]">https://blog.csdn.net/qq_42402854/article/details/130932936]</a>: </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>服务器消息推送</tag>
        <tag>长连接</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>location路径匹配与属性</title>
    <url>/2024/10/17/location%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E4%B8%8E%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="一、location-路径匹配"><a href="#一、location-路径匹配" class="headerlink" title="一、location-路径匹配"></a>一、location-路径匹配</h1><p><strong>优先级从上到下依次匹配：</strong></p>
<ul>
<li>&#x3D;       开头表示精准匹配；精准匹配，成功则会立即停止其他类型匹配；</li>
<li>^~     开头表示uri以某个常规字符串开头，不是正则匹配，一般匹配目录（不区分大小写）；成功则会立即停止其他类型匹配；</li>
<li>~       开头表示正则匹配（区分大小写），!~ 开头表示正则不匹配；多个正则匹配时，按出现的先后顺序，命中则停止；</li>
<li>~*     开头表示正则匹配（不区分大小写），!~* 开头表示正则不匹配；多个正则匹配时，按出现的先后顺序，命中则停止；</li>
<li>&#x2F;aaa 开头表示普通前缀匹配，命中最长的匹配，与顺序无关；成功会暂存，继续其他类型匹配；</li>
<li>&#x2F;       通用匹配, 如果没有其它匹配,任何请求都会匹配到；</li>
</ul>
<p><strong>location 进行的是模糊匹配：</strong></p>
<p>没有“&#x2F;”结尾时，location &#x2F;abc&#x2F;def 可以匹配 &#x2F;abc&#x2F;defghi 请求，也可以匹配 &#x2F;abc&#x2F;def&#x2F;ghi 等；</p>
<p>有“&#x2F;”结尾时，location &#x2F;abc&#x2F;def&#x2F; 不能匹配 &#x2F;abc&#x2F;defghi 请求，只能匹配 &#x2F;abc&#x2F;def&#x2F;anything 这样的请求。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例子1 ^~ 匹配：</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> website.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ ^/doc[a-z]+</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">701</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ ^/docu[a-z]+</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">702</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl -I website.com:8080/document 返回 HTTP/1.1 701</span></span><br><span class="line"><span class="comment"># 说明：多个正则匹配时使用文件中的顺序，先匹配成功的返回。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例子2 普通前缀匹配：</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> website.com;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> /docu &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">701</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> /doc &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">702</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># curl -I website.com:8080/document 会返回 HTTP/1.1 701</span></span><br><span class="line"><span class="comment"># 说明：前缀匹配下，返回最长匹配的 location，与 location 所在位置顺序无关。</span></span><br></pre></td></tr></table></figure>

<h1 id="二、location-属性"><a href="#二、location-属性" class="headerlink" title="二、location-属性"></a>二、location-属性</h1><h2 id="root"><a href="#root" class="headerlink" title="root:"></a>root:</h2><p>location中root指定的只是相对路径，需要和路径结合起来映射地址；</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span><span class="regexp"> ^~/static/</span> &#123;	<span class="comment">## 这里的root需要和路径结合使用，即是映射的文件位置为 /usr/alyingboy/static</span></span><br><span class="line">    <span class="attribute">root</span> /usr/alyingboy/; </span><br><span class="line">    <span class="attribute">index</span> index.html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时访问 IP/static/a.css ，那么就会找到 /usr/alyingboy/static/a.css</span></span><br><span class="line"><span class="comment">#如果定义的路径是文件夹，那么需要使用/结尾</span></span><br></pre></td></tr></table></figure>

<h2 id="alias"><a href="#alias" class="headerlink" title="alias:"></a>alias:</h2><p>alias指定的是绝对路径，不会和location中的路径结合使用，而是直接使用地址映射到文件;</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span><span class="regexp"> ^~/static/</span> &#123;	<span class="comment">## 不会路径结合映射地址，那么这里就会直接映射到/usr/alyingboy/文件夹下的文件</span></span><br><span class="line">    <span class="attribute">alias</span> /usr/alyingboy/; </span><br><span class="line">    <span class="attribute">index</span> index.html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果定义的路径是文件夹，那么需要使用/结尾</span></span><br></pre></td></tr></table></figure>

<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass:"></a>proxy_pass:</h2><p>在nginx中配置proxy_pass代理转发时，</p>
<p>如果在proxy_pass后面的url加&#x2F;，表示绝对根路径；</p>
<p>如果没有&#x2F;，表示相对路径，把匹配的路径部分也给代理走。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">假设下面四种情况分别用 http://192.168.1.1/proxy/test.<span class="attribute">html</span> 进行访问。</span><br><span class="line"></span><br><span class="line">第一种：location /proxy/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1/;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http://127.0.0.1/test.<span class="attribute">html</span></span><br><span class="line"></span><br><span class="line">第二种（相对于第一种，最后少一个 / ）</span><br><span class="line">location /proxy/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http://127.0.0.1/proxy/test.<span class="attribute">html</span></span><br><span class="line"></span><br><span class="line">第三种：location /proxy/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1/aaa/;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http://127.0.0.1/aaa/test.<span class="attribute">html</span></span><br><span class="line"></span><br><span class="line">第四种（相对于第三种，最后少一个 / ）</span><br><span class="line">location /proxy/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1/aaa;</span><br><span class="line">&#125;</span><br><span class="line">代理到URL：http://127.0.0.1/aaatest.html</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>代码耗时统计</title>
    <url>/2021/10/10/%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="一、计算时间差："><a href="#一、计算时间差：" class="headerlink" title="一、计算时间差："></a>一、计算时间差：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方式一:</span></span><br><span class="line"><span class="comment">* 当前时间 - 开始时间 获得耗时时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方式二</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">System.out.println(<span class="string">&quot;执行耗时：&quot;</span> + (<span class="keyword">new</span> <span class="title class_">Date</span>().getTime() - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>优点：使用简单，只是估算一下耗时的话用这种就可以。</p>
<p>缺点：如果分析一段代码中多个节点耗时的话，结构不清晰。</p>
<h2 id="二、工具类StopWatch："><a href="#二、工具类StopWatch：" class="headerlink" title="二、工具类StopWatch："></a>二、工具类StopWatch：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StopWatch</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line"></span><br><span class="line">sw.start(<span class="string">&quot;业务一&quot;</span>);</span><br><span class="line"><span class="comment">//业务代码...</span></span><br><span class="line">sw.stop();</span><br><span class="line"></span><br><span class="line">sw.start(<span class="string">&quot;业务二&quot;</span>);</span><br><span class="line"><span class="comment">//业务代码...</span></span><br><span class="line">sw.stop();</span><br></pre></td></tr></table></figure>

<p>StopWatch其他方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StopWatch</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line"></span><br><span class="line">sw.start(<span class="string">&quot;开始任务&quot;</span>);</span><br><span class="line">sw.stop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//美化打印输出</span></span><br><span class="line">System.out.println(sw.prettyPrint());  </span><br><span class="line"><span class="comment">//总时间 ms</span></span><br><span class="line">System.out.println(sw.getTotalTimeMillis());  </span><br><span class="line"><span class="comment">//最后一个 任务名称</span></span><br><span class="line">System.out.println(sw.getLastTaskName());  </span><br><span class="line"><span class="comment">//最后一个 任务信息</span></span><br><span class="line">System.out.println(sw.getLastTaskInfo());  </span><br><span class="line"><span class="comment">//任务总数</span></span><br><span class="line">System.out.println(sw.getTaskCount());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>海康摄像头对接方案选型</title>
    <url>/2024/11/22/%E6%B5%B7%E5%BA%B7%E6%91%84%E5%83%8F%E5%A4%B4%E5%AF%B9%E6%8E%A5%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p>公司一个项目，业务涉及硬件，设备A传递电信号给海康摄像头，海康摄像头接收报警输入以后，控制录像，并将录像视频传递到服务器上，我们开发的系统是web应用，最终需要在web上播放该视频。</p>
<span id="more"></span>

<p><strong>海康开放平台：</strong></p>
<p><a href="https://open.hikvision.com/">https://open.hikvision.com/</a></p>
<h3 id="方案一：ISUP协议"><a href="#方案一：ISUP协议" class="headerlink" title="方案一：ISUP协议"></a>方案一：ISUP协议</h3><p>首先一种方案是使用ISUP-SDK，海康的ISUP协议解决了摄像头没有固定IP的问题；但是你下载下来，示例基本都是C++的，对于我们开发WEB应用的JAVA工程师来说，简直一头雾水；虽然现在海康也提供了JAVA示例，但是你要是从零开始，让WEB应用直接和硬件层对接，难度还是太大，学习成本很高。</p>
<p>优点：</p>
<ul>
<li>会C++可以尝试一下，SDK免费的；</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于JAVA开发来说难度大，研究起来耗时很长；</li>
<li>沟通海康客服，要定制化就要花钱（具体没问多少，定制化肯定花钱不少，而且定制化也要花一定的时间）；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xibeifen/blogImage@main/img/image-20241122161803470.png" alt="image-20241122161803470"></p>
<h3 id="方案二：萤石云平台"><a href="#方案二：萤石云平台" class="headerlink" title="方案二：萤石云平台"></a>方案二：萤石云平台</h3><p>优点</p>
<ul>
<li><p>ISUP协议是硬件层，我们的WEB应用是软件层，硬件层和软件层交互，要处理事情很多；萤石云平台属于软件应用层，它可以直接给我们开放接口，我们应用直接调用现成的接口就容易多了；</p>
</li>
<li><p>有专门接口文档，入参出参很清晰；能对接海康、大华多种品牌；</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>甲方公司不建议使用第三方平台；</p>
</li>
<li><p>每个月几百块的费用，一些服务还要另外收费；</p>
</li>
<li><p>海康客服提示，通过萤石云只能进行视频预览、回放，获取不到IO报警信号及报警录像；因此，尚不能满足我们的业务需求。</p>
</li>
</ul>
<h3 id="方案三：综合安防管理平台"><a href="#方案三：综合安防管理平台" class="headerlink" title="方案三：综合安防管理平台"></a>方案三：综合安防管理平台</h3><p><img src="https://cdn.jsdelivr.net/gh/xibeifen/blogImage@main/img/image-20241122163156684.png" alt="image-20241122163156684"></p>
<p>综合安防平台是独立部署的，可以安装需要的模块在自己的服务器上，你也可以花钱对它进行定制化，因此不算第三方平台；另一方面，它是一次性付费几千元，需求稳定的话，一次支付可以永久使用。它的功能也满足我们的需求，点击“场景方案”，可以看到，我们需要用的主要是两个，一个是事件订阅，一个是回放取流。</p>
<ul>
<li>价格在预算之内，并且一次性收费；</li>
<li>独立部署；</li>
<li>后续要升级修改功能，也可以定制化，有一定的扩展性；</li>
<li>官方文档还算清晰，结合咨询海康的技术和客服人员，大部分问题就可以解决；</li>
</ul>
<p><strong>具体步骤大致如下</strong></p>
<p>1、开发时，我们没有设备A，可以用一根铜线短接摄像头报警接口，以此来模拟报警输入信号；注意是IN和G，接头上有标记。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xibeifen/blogImage@main/img/image-20241122164541316.png" alt="image-20241122164541316"></p>
<p>2、摄像头配置不做描述，假设这里摄像头已经运行了。那么我们进入配置页面，在“事件“中选择报警输入，配置录像，并在录像中选择录制时长。这是，一旦短接模拟报警输入以后，就会自动录制一段视频。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xibeifen/blogImage@main/img/image-20241122171233614.png" alt="image-20241122171233614"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xibeifen/blogImage@main/img/2aed994e3679597c2650a6e74ac8c28.png" alt="2aed994e3679597c2650a6e74ac8c28"></p>
<p>3、采购综合安防平台，然后让海康技术配置好，剩下就是我们的事了；用到的第一个接口是“事件服务接口”-“按事件类型订阅事件”，这个接口我是配置在应用启动时，自动触发，它会给综合安防管理平台发送一个接口地址，当事件触发时，会安防平台会调用这个接口地址，传输相关的报文信息。当然，这个接口地址就是我们WEB应用对我开放的一个接口，你需要事先按文档规范编写好。</p>
<p>这里用到两个接口，接口1由安防平台提供，你可以在“开发指南”中找到：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xibeifen/blogImage@main/img/image-20241122170441747.png" alt="image-20241122170441747"></p>
<p>接口2由你自己编写，是事件触发后回调的地址，接收到报文后，处理自己的业务；我这里是接收报警输入的时间，然后调用“回放取流”接口，取出mp4格式的视频文件并存放到服务器上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * contorller接口</span></span><br><span class="line"><span class="comment"> * 报警事件触发时，请求的接口：</span></span><br><span class="line"><span class="comment"> * 接收报警时间、设备ID等报文数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 报文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/receiveData&quot;, method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">receiveData</span><span class="params">(<span class="meta">@RequestBody</span> String data)</span> &#123;</span><br><span class="line">    <span class="comment">//异步执行接收报文</span></span><br><span class="line">    cameraService.receiveData(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回消息</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jsonBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    jsonBody.put(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    jsonBody.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">    jsonBody.put(<span class="string">&quot;data&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> jsonBody.toJSONString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * service业务处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveData</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;收到预警事件报文：&#123;&#125;&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(data)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;预警事件报文为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、这里可以用Hutool工具类解析报文</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.parseObj(data);</span><br><span class="line">    <span class="comment">//Params字段</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">paramsJson</span> <span class="operator">=</span> jsonObject.getJSONObject(<span class="string">&quot;params&quot;</span>);</span><br><span class="line">    <span class="comment">//Events字段</span></span><br><span class="line">    <span class="type">JSONArray</span> <span class="variable">eventsJson</span> <span class="operator">=</span> paramsJson.getJSONArray(<span class="string">&quot;events&quot;</span>);</span><br><span class="line">    <span class="comment">//第一个事件</span></span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">eventJson</span> <span class="operator">=</span> eventsJson.getJSONObject(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//status字段</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> eventJson.getInt(<span class="string">&quot;status&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//2、预警开始，新增预警信息</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//3、预警结束，回放取流，下载视频</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;预警事件状态异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>海康</category>
      </categories>
      <tags>
        <tag>海康</tag>
        <tag>摄像头</tag>
        <tag>视频监控</tag>
        <tag>流媒体服务</tag>
      </tags>
  </entry>
  <entry>
    <title>编程式事务</title>
    <url>/2019/08/10/%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h4 id="一、Spring中使用事务的两种方式"><a href="#一、Spring中使用事务的两种方式" class="headerlink" title="一、Spring中使用事务的两种方式"></a>一、Spring中使用事务的两种方式</h4><ul>
<li><p>编程式事务：</p>
<p>通过硬编码的方式来控制事务。</p>
</li>
<li><p>声明式事务：</p>
<p>使用注解@Transaction的方式。</p>
</li>
</ul>
<h4 id="二、编程式事务"><a href="#二、编程式事务" class="headerlink" title="二、编程式事务"></a>二、编程式事务</h4><p>通过注入 DataSourceTransactionManager 来手动开启事务，手动回滚事务，用于抛出异常被catch后，进行手动回滚，可控程度更高，可以更灵活的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  方式一：手动提交、手动回滚；阿里巴巴推荐的方式；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IxxxService</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  自动装配 数据源事务管理器；</span></span><br><span class="line"><span class="comment">    *  注意：前提是容器中要有可装配的事务管理器，如果没有那么需要注入；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSourceTransactionManager transactionManager;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">xxxServiceImpl</span><span class="params">(DataSourceTransactionManager transactionManager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transactionManager = transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">xxx</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//配置事务策略</span></span><br><span class="line">        <span class="type">DefaultTransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        def.setName(<span class="string">&quot;planOne-transaction&quot;</span>);</span><br><span class="line">        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置状态点</span></span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">transactionStatus</span> <span class="operator">=</span> transactionManager.getTransaction(def);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//手动提交事务</span></span><br><span class="line">            transactionManager.commit(transactionStatus);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//手动回滚事务</span></span><br><span class="line">            transactionManager.rollback(transactionStatus);</span><br><span class="line">            log.error(<span class="string">&quot;重新下发排版规则，发生异常，已回滚！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 方式二：自动提交、手动回滚；加上了@Transactional，去除了transactionManager.commit(status); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">   <span class="comment">//注入事务管理对象</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> DataSourceTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">       <span class="type">DefaultTransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">       def.setName(<span class="string">&quot;SomeTxName&quot;</span>);</span><br><span class="line">       def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//开启一个事务</span></span><br><span class="line">       <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(def);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//执行你的代码逻辑，数据库操作</span></span><br><span class="line">           <span class="comment">//自动提交事务</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">           <span class="comment">//回滚事务</span></span><br><span class="line">           transactionManager.rollback(status);</span><br><span class="line">           <span class="keyword">throw</span> ex;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>事务</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
</search>
